# Bootstrap Parser for FORMA
# Recursive descent parser with index-based AST

# ============================================================================
# Parser State
# ============================================================================

s Parser
    tokens: [Token]    # Input tokens from lexer
    pos: Int           # Current position in token stream
    ast: AST           # AST being built

f parser_new(tokens: [Token]) -> Parser
    Parser {
        tokens: tokens,
        pos: 0,
        ast: ast_new()
    }

# ============================================================================
# Token Access
# ============================================================================

f at_end(p: Parser) -> Bool
    p.pos >= vec_len(p.tokens)

f current(p: Parser) -> Token
    if at_end(p) then p.tokens[vec_len(p.tokens) - 1]
    else p.tokens[p.pos]

f peek(p: Parser) -> Option[Token]
    if p.pos + 1 >= vec_len(p.tokens) then None
    else Some(p.tokens[p.pos + 1])

f current_span(p: Parser) -> Span
    tok := current(p)
    tok.span

f advance(p: Parser) -> Parser
    if at_end(p) then p
    else Parser { tokens: p.tokens, pos: p.pos + 1, ast: p.ast }

f check(p: Parser, kind: Int) -> Bool
    if at_end(p) then false
    else current(p).kind == kind

f check_ident(p: Parser) -> Bool
    check(p, TK_IDENT())

f match_token(p: Parser, kind: Int) -> (Parser, Bool)
    if check(p, kind) then (advance(p), true)
    else (p, false)

f expect_token(p: Parser, kind: Int) -> (Parser, Bool)
    if check(p, kind) then (advance(p), true)
    else (p, false)

f skip_newlines(p: Parser) -> Parser
    done := false
    result := p
    wh !done
        if check(result, TK_NEWLINE()) then result = advance(result)
        else done = true
    result

# ============================================================================
# Error Handling
# ============================================================================

s ParseError
    message: Str
    span: Span

f error(p: Parser, msg: Str) -> ParseError
    ParseError { message: msg, span: current_span(p) }

# ============================================================================
# Expression Parsing (Pratt Parser)
# ============================================================================

# Precedence levels
f PREC_NONE() -> Int = 0
f PREC_ASSIGN() -> Int = 1
f PREC_OR() -> Int = 2
f PREC_AND() -> Int = 3
f PREC_EQ() -> Int = 4
f PREC_CMP() -> Int = 5
f PREC_TERM() -> Int = 6
f PREC_FACTOR() -> Int = 7
f PREC_UNARY() -> Int = 8
f PREC_CALL() -> Int = 9
f PREC_PRIMARY() -> Int = 10

# Get precedence of binary operator
f bin_op_precedence(kind: Int) -> Int
    if kind == TK_PIPEPIPE() then PREC_OR()
    else if kind == TK_AMPAMP() then PREC_AND()
    else if kind == TK_EQEQ() || kind == TK_BANGEQ() then PREC_EQ()
    else if kind == TK_LT() || kind == TK_LTEQ() || kind == TK_GT() || kind == TK_GTEQ() then PREC_CMP()
    else if kind == TK_PLUS() || kind == TK_MINUS() then PREC_TERM()
    else if kind == TK_STAR() || kind == TK_SLASH() || kind == TK_PERCENT() then PREC_FACTOR()
    else PREC_NONE()

# Get operator kind for AST
f token_to_bin_op(kind: Int) -> Int
    if kind == TK_PLUS() then OP_ADD()
    else if kind == TK_MINUS() then OP_SUB()
    else if kind == TK_STAR() then OP_MUL()
    else if kind == TK_SLASH() then OP_DIV()
    else if kind == TK_PERCENT() then OP_REM()
    else if kind == TK_EQEQ() then OP_EQ()
    else if kind == TK_BANGEQ() then OP_NE()
    else if kind == TK_LT() then OP_LT()
    else if kind == TK_LTEQ() then OP_LE()
    else if kind == TK_GT() then OP_GT()
    else if kind == TK_GTEQ() then OP_GE()
    else if kind == TK_AMPAMP() then OP_AND()
    else if kind == TK_PIPEPIPE() then OP_OR()
    else 0

# Parse primary expression (literals, identifiers, parenthesized, control flow)
f parse_primary(p: Parser) -> (Parser, Int)
    tok := current(p)
    span := tok.span

    # If expression
    if tok.kind == TK_IF() then
        parse_if_expr(p)

    # While expression
    else if tok.kind == TK_WH() then
        parse_while_expr(p)

    # Match expression
    else if tok.kind == TK_M() then
        parse_match_expr(p)

    # Return expression: ret expr or ret
    else if tok.kind == TK_RET() then
        parse_return_expr(p)

    # Break expression
    else if tok.kind == TK_BR() then
        p2 := advance(p)
        expr := expr_new(EXPR_BREAK(), span)
        (ast2, idx) := ast_add_expr(p.ast, expr)
        (Parser { tokens: p2.tokens, pos: p2.pos, ast: ast2 }, idx)

    # Continue expression
    else if tok.kind == TK_CT() then
        p2 := advance(p)
        expr := expr_new(EXPR_CONTINUE(), span)
        (ast2, idx) := ast_add_expr(p.ast, expr)
        (Parser { tokens: p2.tokens, pos: p2.pos, ast: ast2 }, idx)

    # Integer literal
    else if tok.kind == TK_INT() then
        expr := expr_new(EXPR_INT(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: tok.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    # Float literal
    else if tok.kind == TK_FLOAT() then
        expr := expr_new(EXPR_FLOAT(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: tok.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    # String literal
    else if tok.kind == TK_STRING() then
        expr := expr_new(EXPR_STR(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: tok.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    # Bool literals
    else if tok.kind == TK_TRUE() then
        expr := expr_new(EXPR_BOOL(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: true, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    else if tok.kind == TK_FALSE() then
        expr := expr_new(EXPR_BOOL(), span)
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    # Identifier
    else if tok.kind == TK_IDENT() then
        expr := expr_new(EXPR_IDENT(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: tok.str_val, name: tok.str_val, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (advance(p2), idx)
    
    # Parenthesized expression
    else if tok.kind == TK_LPAREN() then
        p2 := advance(p)
        (p3, expr_idx) := parse_expr(p2)
        (p4, _) := expect_token(p3, TK_RPAREN())
        (p4, expr_idx)
    
    # Error case - return dummy expr
    else
        expr := expr_new(EXPR_INT(), span)
        (ast2, idx) := ast_add_expr(p.ast, expr)
        p2 := Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }
        (p2, idx)

# Parse unary expression
f parse_unary(p: Parser) -> (Parser, Int)
    tok := current(p)
    span := tok.span
    
    if tok.kind == TK_MINUS() then
        p2 := advance(p)
        (p3, operand) := parse_unary(p2)
        expr := expr_new(EXPR_UNARY(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: UNOP_NEG(), right: expr.right, operand: operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p3.ast, expr)
        (Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, idx)
    
    else if tok.kind == TK_BANG() then
        p2 := advance(p)
        (p3, operand) := parse_unary(p2)
        expr := expr_new(EXPR_UNARY(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: UNOP_NOT(), right: expr.right, operand: operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p3.ast, expr)
        (Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, idx)
    
    else
        parse_call(p)

# Parse call/method/field access (postfix)
f parse_call(p: Parser) -> (Parser, Int)
    (p2, expr_idx) := parse_primary(p)
    parse_postfix(p2, expr_idx)

f parse_postfix(p: Parser, expr_idx: Int) -> (Parser, Int)
    tok := current(p)
    
    # Function call
    if tok.kind == TK_LPAREN() then
        p2 := advance(p)
        (p3, args) := parse_args(p2)
        (p4, _) := expect_token(p3, TK_RPAREN())
        
        base_expr := p4.ast.exprs[expr_idx]
        call_expr := expr_new(EXPR_CALL(), span_merge(base_expr.span, current_span(p4)))
        call_expr = ExprNode { kind: call_expr.kind, span: call_expr.span, int_val: call_expr.int_val, float_val: call_expr.float_val, bool_val: call_expr.bool_val, char_val: call_expr.char_val, str_val: call_expr.str_val, name: call_expr.name, left: call_expr.left, op: call_expr.op, right: call_expr.right, operand: call_expr.operand, callee: expr_idx, args: args, object: call_expr.object, field: call_expr.field, elements: call_expr.elements, condition: call_expr.condition, then_branch: call_expr.then_branch, else_branch: call_expr.else_branch, scrutinee: call_expr.scrutinee, arms: call_expr.arms, body_block: call_expr.body_block, stmts: call_expr.stmts, type_name: call_expr.type_name, field_inits: call_expr.field_inits }
        (ast2, idx) := ast_add_expr(p4.ast, call_expr)
        parse_postfix(Parser { tokens: p4.tokens, pos: p4.pos, ast: ast2 }, idx)
    
    # Field access
    else if tok.kind == TK_DOT() then
        p2 := advance(p)
        field_tok := current(p2)
        if field_tok.kind == TK_IDENT() then
            p3 := advance(p2)
            base_expr := p3.ast.exprs[expr_idx]
            field_expr := expr_new(EXPR_FIELD(), span_merge(base_expr.span, field_tok.span))
            field_expr = ExprNode { kind: field_expr.kind, span: field_expr.span, int_val: field_expr.int_val, float_val: field_expr.float_val, bool_val: field_expr.bool_val, char_val: field_expr.char_val, str_val: field_expr.str_val, name: field_expr.name, left: field_expr.left, op: field_expr.op, right: field_expr.right, operand: field_expr.operand, callee: field_expr.callee, args: field_expr.args, object: expr_idx, field: field_tok.str_val, elements: field_expr.elements, condition: field_expr.condition, then_branch: field_expr.then_branch, else_branch: field_expr.else_branch, scrutinee: field_expr.scrutinee, arms: field_expr.arms, body_block: field_expr.body_block, stmts: field_expr.stmts, type_name: field_expr.type_name, field_inits: field_expr.field_inits }
            (ast2, idx) := ast_add_expr(p3.ast, field_expr)
            parse_postfix(Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, idx)
        else
            (p2, expr_idx)
    
    # Index access
    else if tok.kind == TK_LBRACKET() then
        p2 := advance(p)
        (p3, index_expr) := parse_expr(p2)
        (p4, _) := expect_token(p3, TK_RBRACKET())
        
        base_expr := p4.ast.exprs[expr_idx]
        idx_expr := expr_new(EXPR_INDEX(), span_merge(base_expr.span, current_span(p4)))
        idx_expr = ExprNode { kind: idx_expr.kind, span: idx_expr.span, int_val: idx_expr.int_val, float_val: idx_expr.float_val, bool_val: idx_expr.bool_val, char_val: idx_expr.char_val, str_val: idx_expr.str_val, name: idx_expr.name, left: expr_idx, op: idx_expr.op, right: index_expr, operand: idx_expr.operand, callee: idx_expr.callee, args: idx_expr.args, object: idx_expr.object, field: idx_expr.field, elements: idx_expr.elements, condition: idx_expr.condition, then_branch: idx_expr.then_branch, else_branch: idx_expr.else_branch, scrutinee: idx_expr.scrutinee, arms: idx_expr.arms, body_block: idx_expr.body_block, stmts: idx_expr.stmts, type_name: idx_expr.type_name, field_inits: idx_expr.field_inits }
        (ast2, idx) := ast_add_expr(p4.ast, idx_expr)
        parse_postfix(Parser { tokens: p4.tokens, pos: p4.pos, ast: ast2 }, idx)
    
    else
        (p, expr_idx)

# ============================================================================
# Control Flow Expressions
# ============================================================================

# Parse return expression: ret expr or ret (returns unit)
f parse_return_expr(p: Parser) -> (Parser, Int)
    span := current_span(p)
    p2 := advance(p)  # consume 'ret'

    # Check if there's a value to return (not at end, newline, dedent, or else)
    tok := current(p2)
    if at_end(p2) || tok.kind == TK_NEWLINE() || tok.kind == TK_DEDENT() || tok.kind == TK_ELSE() then
        # Return unit
        expr := expr_new(EXPR_RETURN(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: -1, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p2.ast, expr)
        (Parser { tokens: p2.tokens, pos: p2.pos, ast: ast2 }, idx)
    else
        # Return with value
        (p3, val) := parse_expr(p2)
        expr := expr_new(EXPR_RETURN(), span)
        expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: val, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: expr.condition, then_branch: expr.then_branch, else_branch: expr.else_branch, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
        (ast2, idx) := ast_add_expr(p3.ast, expr)
        (Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, idx)

# Parse if expression: if cond then expr else expr
f parse_if_expr(p: Parser) -> (Parser, Int)
    span := current_span(p)
    p2 := advance(p)  # consume 'if'

    # Parse condition
    (p3, cond) := parse_expr(p2)

    # Expect 'then'
    (p4, _) := expect_token(p3, TK_THEN())

    # Parse then branch
    (p5, then_br) := parse_expr(p4)

    # Parse optional else branch
    if check(p5, TK_ELSE()) then
        p6 := advance(p5)
        (p7, else_br) := parse_expr(p6)
        (new_ast, idx) := make_if_expr(p7.ast, span, cond, then_br, else_br)
        (Parser { tokens: p7.tokens, pos: p7.pos, ast: new_ast }, idx)
    else
        (new_ast, idx) := make_if_expr(p5.ast, span, cond, then_br, -1)
        (Parser { tokens: p5.tokens, pos: p5.pos, ast: new_ast }, idx)

f make_if_expr(ast: AST, span: Span, cond: Int, then_br: Int, else_br: Int) -> (AST, Int)
    expr := expr_new(EXPR_IF(), span)
    expr = ExprNode { kind: expr.kind, span: expr.span, int_val: expr.int_val, float_val: expr.float_val, bool_val: expr.bool_val, char_val: expr.char_val, str_val: expr.str_val, name: expr.name, left: expr.left, op: expr.op, right: expr.right, operand: expr.operand, callee: expr.callee, args: expr.args, object: expr.object, field: expr.field, elements: expr.elements, condition: cond, then_branch: then_br, else_branch: else_br, scrutinee: expr.scrutinee, arms: expr.arms, body_block: expr.body_block, stmts: expr.stmts, type_name: expr.type_name, field_inits: expr.field_inits }
    ast_add_expr(ast, expr)

# Parse while expression: wh cond { body } or wh cond INDENT body DEDENT
f parse_while_expr(p: Parser) -> (Parser, Int)
    span := current_span(p)
    p2 := advance(p)  # consume 'wh'

    # Parse condition
    (p3, cond) := parse_expr(p2)

    # Skip newline and parse body
    p4 := skip_newlines(p3)

    # Check for indent (block body) or inline
    if check(p4, TK_INDENT()) then
        p5 := advance(p4)  # consume INDENT
        (p6, body_stmts) := parse_block_stmts(p5)
        (p7, _) := expect_token(p6, TK_DEDENT())

        # Create a block expression for the body
        block_expr := expr_new(EXPR_BLOCK(), span)
        block_expr = ExprNode { kind: block_expr.kind, span: block_expr.span, int_val: block_expr.int_val, float_val: block_expr.float_val, bool_val: block_expr.bool_val, char_val: block_expr.char_val, str_val: block_expr.str_val, name: block_expr.name, left: block_expr.left, op: block_expr.op, right: block_expr.right, operand: block_expr.operand, callee: block_expr.callee, args: block_expr.args, object: block_expr.object, field: block_expr.field, elements: block_expr.elements, condition: block_expr.condition, then_branch: block_expr.then_branch, else_branch: block_expr.else_branch, scrutinee: block_expr.scrutinee, arms: block_expr.arms, body_block: block_expr.body_block, stmts: body_stmts, type_name: block_expr.type_name, field_inits: block_expr.field_inits }
        (ast2, body_idx) := ast_add_expr(p7.ast, block_expr)

        # Create while expression
        while_expr := expr_new(EXPR_WHILE(), span)
        while_expr = ExprNode { kind: while_expr.kind, span: while_expr.span, int_val: while_expr.int_val, float_val: while_expr.float_val, bool_val: while_expr.bool_val, char_val: while_expr.char_val, str_val: while_expr.str_val, name: while_expr.name, left: while_expr.left, op: while_expr.op, right: while_expr.right, operand: while_expr.operand, callee: while_expr.callee, args: while_expr.args, object: while_expr.object, field: while_expr.field, elements: while_expr.elements, condition: cond, then_branch: while_expr.then_branch, else_branch: while_expr.else_branch, scrutinee: while_expr.scrutinee, arms: while_expr.arms, body_block: body_idx, stmts: while_expr.stmts, type_name: while_expr.type_name, field_inits: while_expr.field_inits }
        (ast3, idx) := ast_add_expr(ast2, while_expr)
        (Parser { tokens: p7.tokens, pos: p7.pos, ast: ast3 }, idx)
    else
        # Inline while body (single expression)
        (p5, body) := parse_expr(p4)
        while_expr := expr_new(EXPR_WHILE(), span)
        while_expr = ExprNode { kind: while_expr.kind, span: while_expr.span, int_val: while_expr.int_val, float_val: while_expr.float_val, bool_val: while_expr.bool_val, char_val: while_expr.char_val, str_val: while_expr.str_val, name: while_expr.name, left: while_expr.left, op: while_expr.op, right: while_expr.right, operand: while_expr.operand, callee: while_expr.callee, args: while_expr.args, object: while_expr.object, field: while_expr.field, elements: while_expr.elements, condition: cond, then_branch: while_expr.then_branch, else_branch: while_expr.else_branch, scrutinee: while_expr.scrutinee, arms: while_expr.arms, body_block: body, stmts: while_expr.stmts, type_name: while_expr.type_name, field_inits: while_expr.field_inits }
        (ast2, idx) := ast_add_expr(p5.ast, while_expr)
        (Parser { tokens: p5.tokens, pos: p5.pos, ast: ast2 }, idx)

# Parse block statements (between INDENT and DEDENT)
f parse_block_stmts(p: Parser) -> (Parser, [Int])
    parse_block_stmts_loop(p, [])

f parse_block_stmts_loop(p: Parser, stmts: [Int]) -> (Parser, [Int])
    p2 := skip_newlines(p)
    if check(p2, TK_DEDENT()) || at_end(p2) then (p2, stmts)
    else
        (p3, stmt_idx) := parse_statement(p2)
        new_stmts := vec_push(stmts, stmt_idx)
        p4 := skip_newlines(p3)
        parse_block_stmts_loop(p4, new_stmts)

# Parse a single statement - either let binding or expression
f parse_statement(p: Parser) -> (Parser, Int)
    # Check for let statement: name := expr or (pattern) := expr
    (p2, is_let) := try_parse_let(p)
    if is_let then (p2, vec_len(p2.ast.stmts) - 1)
    else
        # Parse as expression statement
        (p3, stmt_expr) := parse_expr(p)
        stmt := stmt_new(STMT_EXPR(), p3.ast.exprs[stmt_expr].span)
        stmt = StmtNode { kind: stmt.kind, span: stmt.span, expr: stmt_expr, pattern: stmt.pattern, init: stmt.init, mutable: stmt.mutable, item: stmt.item }
        (ast2, stmt_idx) := ast_add_stmt(p3.ast, stmt)
        (Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, stmt_idx)

# Try to parse a let statement, returns (Parser, Bool) where Bool indicates success
f try_parse_let(p: Parser) -> (Parser, Bool)
    tok := current(p)
    span := tok.span

    # Check for simple let: name := expr
    if tok.kind == TK_IDENT() then
        p2 := advance(p)
        if check(p2, TK_COLONEQ()) then
            # It's a let statement
            p3 := advance(p2)  # consume :=
            (p4, init_expr) := parse_expr(p3)

            # Create identifier pattern
            pat := pattern_new(PAT_IDENT(), span)
            pat = PatternNode { kind: pat.kind, span: pat.span, name: tok.str_val, mutable: false, literal: pat.literal, elements: pat.elements, fields: pat.fields }
            (ast2, pat_idx) := ast_add_pattern(p4.ast, pat)

            # Create let statement
            stmt := stmt_new(STMT_LET(), span)
            stmt = StmtNode { kind: stmt.kind, span: stmt.span, expr: stmt.expr, pattern: pat_idx, init: init_expr, mutable: false, item: stmt.item }
            (ast3, _) := ast_add_stmt(ast2, stmt)

            (Parser { tokens: p4.tokens, pos: p4.pos, ast: ast3 }, true)
        else
            (p, false)

    # Check for mutable let: mut name := expr or name = expr (assignment, not let)
    # For now, we treat simple assignment as let for simplicity
    else if tok.kind == TK_LPAREN() then
        # Tuple pattern: (a, b) := expr
        p2 := advance(p)
        (p3, pats) := parse_tuple_pattern_elements(p2)
        (p4, _) := expect_token(p3, TK_RPAREN())

        if check(p4, TK_COLONEQ()) then
            p5 := advance(p4)  # consume :=
            (p6, init_expr) := parse_expr(p5)

            # Create tuple pattern
            pat := pattern_new(PAT_TUPLE(), span)
            pat = PatternNode { kind: pat.kind, span: pat.span, name: pat.name, mutable: false, literal: pat.literal, elements: pats, fields: pat.fields }
            (ast2, pat_idx) := ast_add_pattern(p6.ast, pat)

            # Create let statement
            stmt := stmt_new(STMT_LET(), span)
            stmt = StmtNode { kind: stmt.kind, span: stmt.span, expr: stmt.expr, pattern: pat_idx, init: init_expr, mutable: false, item: stmt.item }
            (ast3, _) := ast_add_stmt(ast2, stmt)

            (Parser { tokens: p6.tokens, pos: p6.pos, ast: ast3 }, true)
        else
            (p, false)
    else
        (p, false)

# Parse tuple pattern elements: a, b, c
f parse_tuple_pattern_elements(p: Parser) -> (Parser, [Int])
    parse_tuple_pattern_elements_loop(p, [])

f parse_tuple_pattern_elements_loop(p: Parser, pats: [Int]) -> (Parser, [Int])
    if check(p, TK_RPAREN()) then (p, pats)
    else
        tok := current(p)
        if tok.kind == TK_IDENT() then
            # Create identifier pattern
            pat := pattern_new(PAT_IDENT(), tok.span)
            pat = PatternNode { kind: pat.kind, span: pat.span, name: tok.str_val, mutable: false, literal: pat.literal, elements: pat.elements, fields: pat.fields }
            (ast2, pat_idx) := ast_add_pattern(p.ast, pat)

            new_pats := vec_push(pats, pat_idx)
            p2 := advance(Parser { tokens: p.tokens, pos: p.pos, ast: ast2 })

            if check(p2, TK_COMMA()) then parse_tuple_pattern_elements_loop(advance(p2), new_pats)
            else (p2, new_pats)
        else
            (p, pats)

# Parse match expression: m scrutinee INDENT arms DEDENT
f parse_match_expr(p: Parser) -> (Parser, Int)
    span := current_span(p)
    p2 := advance(p)  # consume 'm'

    # Parse scrutinee
    (p3, scrut) := parse_expr(p2)

    # Skip newlines and parse arms
    p4 := skip_newlines(p3)

    if check(p4, TK_INDENT()) then
        p5 := advance(p4)  # consume INDENT
        (p6, arms) := parse_match_arms(p5)
        (p7, _) := expect_token(p6, TK_DEDENT())

        match_expr := expr_new(EXPR_MATCH(), span)
        match_expr = ExprNode { kind: match_expr.kind, span: match_expr.span, int_val: match_expr.int_val, float_val: match_expr.float_val, bool_val: match_expr.bool_val, char_val: match_expr.char_val, str_val: match_expr.str_val, name: match_expr.name, left: match_expr.left, op: match_expr.op, right: match_expr.right, operand: match_expr.operand, callee: match_expr.callee, args: match_expr.args, object: match_expr.object, field: match_expr.field, elements: match_expr.elements, condition: match_expr.condition, then_branch: match_expr.then_branch, else_branch: match_expr.else_branch, scrutinee: scrut, arms: arms, body_block: match_expr.body_block, stmts: match_expr.stmts, type_name: match_expr.type_name, field_inits: match_expr.field_inits }
        (ast2, idx) := ast_add_expr(p7.ast, match_expr)
        (Parser { tokens: p7.tokens, pos: p7.pos, ast: ast2 }, idx)
    else
        # Error - match needs arms in a block
        expr := expr_new(EXPR_INT(), span)
        (ast2, idx) := ast_add_expr(p4.ast, expr)
        (Parser { tokens: p4.tokens, pos: p4.pos, ast: ast2 }, idx)

# Parse match arms
f parse_match_arms(p: Parser) -> (Parser, [Int])
    parse_match_arms_loop(p, [])

f parse_match_arms_loop(p: Parser, arms: [Int]) -> (Parser, [Int])
    p2 := skip_newlines(p)
    if check(p2, TK_DEDENT()) || at_end(p2) then (p2, arms)
    else
        (p3, arm_idx) := parse_match_arm(p2)
        new_arms := vec_push(arms, arm_idx)
        p4 := skip_newlines(p3)
        parse_match_arms_loop(p4, new_arms)

# Parse a single match arm: pattern -> body
f parse_match_arm(p: Parser) -> (Parser, Int)
    span := current_span(p)
    (p2, pat) := parse_pattern(p)
    (p3, _) := expect_token(p2, TK_ARROW())
    (p4, body) := parse_expr(p3)

    arm := match_arm_new(pat, body, span)
    (new_ast, idx) := ast_add_match_arm(p4.ast, arm)
    (Parser { tokens: p4.tokens, pos: p4.pos, ast: new_ast }, idx)

# Parse pattern
f parse_pattern(p: Parser) -> (Parser, Int)
    tok := current(p)
    span := tok.span

    # Wildcard pattern: _
    if tok.kind == TK_IDENT() && tok.str_val == "_" then
        pat := pattern_new(PAT_WILDCARD(), span)
        (ast2, idx) := ast_add_pattern(p.ast, pat)
        (Parser { tokens: p.tokens, pos: p.pos + 1, ast: ast2 }, idx)

    # None pattern (unit vformant)
    else if tok.kind == TK_NONE() then
        pat := pattern_new(PAT_IDENT(), span)
        pat = PatternNode { kind: pat.kind, span: pat.span, name: "None", mutable: false, literal: pat.literal, elements: pat.elements, fields: pat.fields }
        (ast2, idx) := ast_add_pattern(p.ast, pat)
        (Parser { tokens: p.tokens, pos: p.pos + 1, ast: ast2 }, idx)

    # Identifier or constructor pattern: name or Name(args)
    else if tok.kind == TK_IDENT() then
        p2 := advance(p)
        # Check for constructor pattern: Some(x) or Name(...)
        if check(p2, TK_LPAREN()) then
            p3 := advance(p2)  # consume (
            (p4, inner_pats) := parse_pattern_args(p3)
            (p5, _) := expect_token(p4, TK_RPAREN())

            # This is a struct/vformant pattern
            pat := pattern_new(PAT_STRUCT(), span)
            fields := build_positional_fields(inner_pats, 0)
            pat = PatternNode { kind: pat.kind, span: pat.span, name: tok.str_val, mutable: false, literal: pat.literal, elements: inner_pats, fields: fields }
            (ast2, idx) := ast_add_pattern(p5.ast, pat)
            (Parser { tokens: p5.tokens, pos: p5.pos, ast: ast2 }, idx)
        else
            # Simple identifier pattern
            pat := pattern_new(PAT_IDENT(), span)
            pat = PatternNode { kind: pat.kind, span: pat.span, name: tok.str_val, mutable: false, literal: pat.literal, elements: pat.elements, fields: pat.fields }
            (ast2, idx) := ast_add_pattern(p.ast, pat)
            (Parser { tokens: p.tokens, pos: p.pos + 1, ast: ast2 }, idx)

    # Integer literal pattern
    else if tok.kind == TK_INT() then
        # Create literal expression
        lit_expr := expr_new(EXPR_INT(), span)
        lit_expr = ExprNode { kind: lit_expr.kind, span: lit_expr.span, int_val: tok.int_val, float_val: lit_expr.float_val, bool_val: lit_expr.bool_val, char_val: lit_expr.char_val, str_val: lit_expr.str_val, name: lit_expr.name, left: lit_expr.left, op: lit_expr.op, right: lit_expr.right, operand: lit_expr.operand, callee: lit_expr.callee, args: lit_expr.args, object: lit_expr.object, field: lit_expr.field, elements: lit_expr.elements, condition: lit_expr.condition, then_branch: lit_expr.then_branch, else_branch: lit_expr.else_branch, scrutinee: lit_expr.scrutinee, arms: lit_expr.arms, body_block: lit_expr.body_block, stmts: lit_expr.stmts, type_name: lit_expr.type_name, field_inits: lit_expr.field_inits }
        (ast2, lit_idx) := ast_add_expr(p.ast, lit_expr)

        pat := pattern_new(PAT_LITERAL(), span)
        pat = PatternNode { kind: pat.kind, span: pat.span, name: pat.name, mutable: false, literal: lit_idx, elements: pat.elements, fields: pat.fields }
        (ast3, idx) := ast_add_pattern(ast2, pat)
        (Parser { tokens: p.tokens, pos: p.pos + 1, ast: ast3 }, idx)

    else
        # Default: wildcard
        pat := pattern_new(PAT_WILDCARD(), span)
        (ast2, idx) := ast_add_pattern(p.ast, pat)
        (Parser { tokens: p.tokens, pos: p.pos, ast: ast2 }, idx)

# Parse pattern arguments for constructor patterns
f parse_pattern_args(p: Parser) -> (Parser, [Int])
    parse_pattern_args_loop(p, [])

f parse_pattern_args_loop(p: Parser, pats: [Int]) -> (Parser, [Int])
    if check(p, TK_RPAREN()) then (p, pats)
    else
        (p2, pat) := parse_pattern(p)
        new_pats := vec_push(pats, pat)
        if check(p2, TK_COMMA()) then parse_pattern_args_loop(advance(p2), new_pats)
        else (p2, new_pats)

# Build positional field list for struct patterns
f build_positional_fields(pats: [Int], idx: Int) -> [(Str, Int)]
    build_positional_fields_acc(pats, idx, [])

f build_positional_fields_acc(pats: [Int], idx: Int, acc: [(Str, Int)]) -> [(Str, Int)]
    if idx >= vec_len(pats) then acc
    else
        field := (int_to_str(idx), pats[idx])
        new_acc := vec_push(acc, field)
        build_positional_fields_acc(pats, idx + 1, new_acc)

# ============================================================================
# Arguments
# ============================================================================

# Parse function call arguments
f parse_args(p: Parser) -> (Parser, [Int])
    parse_args_loop(p, [])

f parse_args_loop(p: Parser, args: [Int]) -> (Parser, [Int])
    if check(p, TK_RPAREN()) then (p, args)
    else
        (p2, arg) := parse_expr(p)
        new_args := vec_push(args, arg)
        if check(p2, TK_COMMA()) then parse_args_loop(advance(p2), new_args)
        else (p2, new_args)

# Parse binary expression with precedence
f parse_binary(p: Parser, min_prec: Int) -> (Parser, Int)
    (p2, left) := parse_unary(p)
    parse_binary_rhs(p2, left, min_prec)

f parse_binary_rhs(p: Parser, left: Int, min_prec: Int) -> (Parser, Int)
    tok := current(p)
    prec := bin_op_precedence(tok.kind)
    
    if prec <= min_prec then
        (p, left)
    else
        op := token_to_bin_op(tok.kind)
        p2 := advance(p)
        (p3, right) := parse_binary(p2, prec)
        
        left_expr := p3.ast.exprs[left]
        right_expr := p3.ast.exprs[right]
        bin_expr := expr_new(EXPR_BINARY(), span_merge(left_expr.span, right_expr.span))
        bin_expr = ExprNode { kind: bin_expr.kind, span: bin_expr.span, int_val: bin_expr.int_val, float_val: bin_expr.float_val, bool_val: bin_expr.bool_val, char_val: bin_expr.char_val, str_val: bin_expr.str_val, name: bin_expr.name, left: left, op: op, right: right, operand: bin_expr.operand, callee: bin_expr.callee, args: bin_expr.args, object: bin_expr.object, field: bin_expr.field, elements: bin_expr.elements, condition: bin_expr.condition, then_branch: bin_expr.then_branch, else_branch: bin_expr.else_branch, scrutinee: bin_expr.scrutinee, arms: bin_expr.arms, body_block: bin_expr.body_block, stmts: bin_expr.stmts, type_name: bin_expr.type_name, field_inits: bin_expr.field_inits }
        (ast2, idx) := ast_add_expr(p3.ast, bin_expr)
        parse_binary_rhs(Parser { tokens: p3.tokens, pos: p3.pos, ast: ast2 }, idx, min_prec)

# Parse expression
f parse_expr(p: Parser) -> (Parser, Int)
    parse_binary(p, PREC_NONE())

# ============================================================================
# Top Level Parsing
# ============================================================================

f parse_file(p: Parser) -> (Parser, Bool)
    p2 := skip_newlines(p)
    parse_file_loop(p2)

f parse_file_loop(p: Parser) -> (Parser, Bool)
    if at_end(p) then (p, true)
    else
        # Try parsing function
        (p2, ok) := parse_item_fn(p)
        if ok then parse_file_loop(skip_newlines(p2))
        else
            # Try parsing struct
            (p3, ok2) := parse_item_struct(p)
            if ok2 then parse_file_loop(skip_newlines(p3))
            else
                # Try parsing enum
                (p4, ok3) := parse_item_enum(p)
                if ok3 then parse_file_loop(skip_newlines(p4))
                else (p, false)

# Parse a function item
f parse_item_fn(p: Parser) -> (Parser, Bool)
    tok := current(p)
    if tok.kind != TK_F() then
        (p, false)
    else
        span := tok.span
        p2 := advance(p)
        
        # Function name
        name_tok := current(p2)
        if name_tok.kind != TK_IDENT() then
            (p2, false)
        else
            p3 := advance(p2)
            name := name_tok.str_val
            
            # Parameters
            (p4, _) := expect_token(p3, TK_LPAREN())
            (p5, params) := parse_params(p4)
            (p6, _) := expect_token(p5, TK_RPAREN())
            
            # Return type
            (p7, ret_type) := parse_optional_return_type(p6)
            
            # Body
            (p8, _) := expect_token(p7, TK_EQ())
            (p9, body) := parse_expr(p8)
            
            # Create function item
            item := item_new(ITEM_FN(), span, name)
            item = ItemNode { kind: item.kind, span: span_merge(span, p9.ast.exprs[body].span), name: name, params: params, return_type: ret_type, body: body, fields: item.fields, vformants: item.vformants }
            (ast2, idx) := ast_add_item(p9.ast, item)
            ast3 := ast_add_top_item(ast2, idx)
            (Parser { tokens: p9.tokens, pos: p9.pos, ast: ast3 }, true)

# Parse a struct item: s Name NEWLINE INDENT fields DEDENT
f parse_item_struct(p: Parser) -> (Parser, Bool)
    tok := current(p)
    if tok.kind != TK_S() then
        (p, false)
    else
        span := tok.span
        p2 := advance(p)

        # Struct name
        name_tok := current(p2)
        if name_tok.kind != TK_IDENT() then
            (p2, false)
        else
            p3 := advance(p2)
            name := name_tok.str_val

            # Skip newline and expect indent
            p4 := skip_newlines(p3)
            if check(p4, TK_INDENT()) then
                p5 := advance(p4)
                (p6, fields) := parse_struct_fields(p5)
                (p7, _) := expect_token(p6, TK_DEDENT())

                # Create struct item
                item := item_new(ITEM_STRUCT(), span, name)
                item = ItemNode { kind: item.kind, span: span, name: name, params: item.params, return_type: item.return_type, body: item.body, fields: fields, vformants: item.vformants }
                (ast2, idx) := ast_add_item(p7.ast, item)
                ast3 := ast_add_top_item(ast2, idx)
                (Parser { tokens: p7.tokens, pos: p7.pos, ast: ast3 }, true)
            else
                # Unit struct (no fields)
                item := item_new(ITEM_STRUCT(), span, name)
                item = ItemNode { kind: item.kind, span: span, name: name, params: item.params, return_type: item.return_type, body: item.body, fields: [], vformants: item.vformants }
                (ast2, idx) := ast_add_item(p4.ast, item)
                ast3 := ast_add_top_item(ast2, idx)
                (Parser { tokens: p4.tokens, pos: p4.pos, ast: ast3 }, true)

f parse_struct_fields(p: Parser) -> (Parser, [(Str, Int)])
    parse_struct_fields_loop(p, [])

f parse_struct_fields_loop(p: Parser, fields: [(Str, Int)]) -> (Parser, [(Str, Int)])
    p2 := skip_newlines(p)
    if check(p2, TK_DEDENT()) || at_end(p2) then (p2, fields)
    else
        (p3, field) := parse_struct_field(p2)
        new_fields := vec_push(fields, field)
        parse_struct_fields_loop(p3, new_fields)

f parse_struct_field(p: Parser) -> (Parser, (Str, Int))
    name_tok := current(p)
    if name_tok.kind != TK_IDENT() then
        (p, ("", -1))
    else
        p2 := advance(p)
        (p3, _) := expect_token(p2, TK_COLON())
        (p4, ty) := parse_type(p3)
        (p4, (name_tok.str_val, ty))

# Parse an enum item: e Name NEWLINE INDENT vformants DEDENT
f parse_item_enum(p: Parser) -> (Parser, Bool)
    tok := current(p)
    if tok.kind != TK_E() then
        (p, false)
    else
        span := tok.span
        p2 := advance(p)

        # Enum name
        name_tok := current(p2)
        if name_tok.kind != TK_IDENT() then
            (p2, false)
        else
            p3 := advance(p2)
            name := name_tok.str_val

            # Skip newline and expect indent
            p4 := skip_newlines(p3)
            if check(p4, TK_INDENT()) then
                p5 := advance(p4)
                (p6, vformants) := parse_enum_vformants(p5)
                (p7, _) := expect_token(p6, TK_DEDENT())

                # Create enum item
                item := item_new(ITEM_ENUM(), span, name)
                item = ItemNode { kind: item.kind, span: span, name: name, params: item.params, return_type: item.return_type, body: item.body, fields: item.fields, vformants: vformants }
                (ast2, idx) := ast_add_item(p7.ast, item)
                ast3 := ast_add_top_item(ast2, idx)
                (Parser { tokens: p7.tokens, pos: p7.pos, ast: ast3 }, true)
            else
                (p4, false)

f parse_enum_vformants(p: Parser) -> (Parser, [(Str, [Int])])
    parse_enum_vformants_loop(p, [])

f parse_enum_vformants_loop(p: Parser, vformants: [(Str, [Int])]) -> (Parser, [(Str, [Int])])
    p2 := skip_newlines(p)
    if check(p2, TK_DEDENT()) || at_end(p2) then (p2, vformants)
    else
        (p3, vformant) := parse_enum_vformant(p2)
        new_vformants := vec_push(vformants, vformant)
        parse_enum_vformants_loop(p3, new_vformants)

f parse_enum_vformant(p: Parser) -> (Parser, (Str, [Int]))
    name_tok := current(p)
    if name_tok.kind != TK_IDENT() then
        (p, ("", []))
    else
        p2 := advance(p)
        name := name_tok.str_val

        # Check for vformant fields: Vformant(Type1, Type2)
        if check(p2, TK_LPAREN()) then
            p3 := advance(p2)
            (p4, types) := parse_vformant_types(p3)
            (p5, _) := expect_token(p4, TK_RPAREN())
            (p5, (name, types))
        else
            # Unit vformant
            (p2, (name, []))

f parse_vformant_types(p: Parser) -> (Parser, [Int])
    parse_vformant_types_loop(p, [])

f parse_vformant_types_loop(p: Parser, types: [Int]) -> (Parser, [Int])
    if check(p, TK_RPAREN()) then (p, types)
    else
        (p2, ty) := parse_type(p)
        new_types := vec_push(types, ty)
        if check(p2, TK_COMMA()) then parse_vformant_types_loop(advance(p2), new_types)
        else (p2, new_types)

f parse_params(p: Parser) -> (Parser, [(Str, Int)])
    parse_params_loop(p, [])

f parse_params_loop(p: Parser, params: [(Str, Int)]) -> (Parser, [(Str, Int)])
    if check(p, TK_RPAREN()) then (p, params)
    else
        (p2, param) := parse_param(p)
        new_params := vec_push(params, param)
        if check(p2, TK_COMMA()) then parse_params_loop(advance(p2), new_params)
        else (p2, new_params)

f parse_param(p: Parser) -> (Parser, (Str, Int))
    name_tok := current(p)
    if name_tok.kind != TK_IDENT() then
        (p, ("", -1))
    else
        p2 := advance(p)
        (p3, _) := expect_token(p2, TK_COLON())
        (p4, ty) := parse_type(p3)
        (p4, (name_tok.str_val, ty))

f parse_optional_return_type(p: Parser) -> (Parser, Int)
    (p2, matched) := match_token(p, TK_ARROW())
    if matched then parse_type(p2)
    else (p, -1)

f parse_type(p: Parser) -> (Parser, Int)
    tok := current(p)
    if tok.kind == TK_IDENT() then
        ty := type_new(TYPE_NAMED(), tok.span)
        ty = TypeNode { kind: ty.kind, span: ty.span, name: tok.str_val, elements: ty.elements, inner: ty.inner, error: ty.error }
        (ast2, idx) := ast_add_type(p.ast, ty)
        (Parser { tokens: p.tokens, pos: p.pos + 1, ast: ast2 }, idx)
    else
        (p, -1)

# ============================================================================
# Main Entry Point
# ============================================================================

f parse(tokens: [Token]) -> AST
    p := parser_new(tokens)
    (p2, _) := parse_file(p)
    p2.ast
