# Bootstrap Type Checker for FORMA
# Functional style: pure functions, state passed through tuples

# ============================================================================
# Type Representation
# ============================================================================

# Type kinds (using integers like AST nodes)
f TY_UNKNOWN() -> Int = 0
f TY_UNIT() -> Int = 1
f TY_INT() -> Int = 2
f TY_FLOAT() -> Int = 3
f TY_BOOL() -> Int = 4
f TY_CHAR() -> Int = 5
f TY_STR() -> Int = 6
f TY_TUPLE() -> Int = 10
f TY_ARRAY() -> Int = 11
f TY_OPTION() -> Int = 12
f TY_RESULT() -> Int = 13
f TY_FN() -> Int = 14
f TY_NAMED() -> Int = 20    # User-defined type (struct/enum)
f TY_VAR() -> Int = 30      # Type vformable for inference

# Type node - represents a type
s Type
    kind: Int
    name: Str           # For TY_NAMED: type name
    elements: [Int]     # For TY_TUPLE, TY_FN (param types): indices into types array
    inner: Int          # For TY_ARRAY, TY_OPTION: inner type index
    ok_type: Int        # For TY_RESULT: ok type index
    err_type: Int       # For TY_RESULT: error type index
    ret_type: Int       # For TY_FN: return type index
    var_id: Int         # For TY_VAR: unique vformable id

f type_new(kind: Int) -> Type
    Type {
        kind: kind,
        name: "",
        elements: [],
        inner: -1,
        ok_type: -1,
        err_type: -1,
        ret_type: -1,
        var_id: -1
    }

# Primitive type constructors
f ty_unit() -> Type = type_new(TY_UNIT())
f ty_int() -> Type = type_new(TY_INT())
f ty_float() -> Type = type_new(TY_FLOAT())
f ty_bool() -> Type = type_new(TY_BOOL())
f ty_char() -> Type = type_new(TY_CHAR())
f ty_str() -> Type = type_new(TY_STR())
f ty_unknown() -> Type = type_new(TY_UNKNOWN())

f ty_option(inner: Int) -> Type
    t := type_new(TY_OPTION())
    Type { kind: t.kind, name: t.name, elements: t.elements, inner: inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: t.ret_type, var_id: t.var_id }

f ty_array(inner: Int) -> Type
    t := type_new(TY_ARRAY())
    Type { kind: t.kind, name: t.name, elements: t.elements, inner: inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: t.ret_type, var_id: t.var_id }

f ty_fn(params: [Int], return_ty: Int) -> Type
    t := type_new(TY_FN())
    Type { kind: t.kind, name: t.name, elements: params, inner: t.inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: return_ty, var_id: t.var_id }

f ty_named(name: Str) -> Type
    t := type_new(TY_NAMED())
    Type { kind: t.kind, name: name, elements: t.elements, inner: t.inner, ok_type: t.ok_type, err_type: t.err_type, ret_type: t.ret_type, var_id: t.var_id }

# ============================================================================
# Type Error
# ============================================================================

s TypeError
    message: Str
    span: Span
    expected: Str
    found: Str

f type_error(msg: Str, span: Span) -> TypeError
    TypeError { message: msg, span: span, expected: "", found: "" }

f type_error_mismatch(span: Span, expected: Str, found: Str) -> TypeError
    TypeError { message: "type mismatch", span: span, expected: expected, found: found }

# ============================================================================
# Type Environment
# ============================================================================

# Environment entry: vformable name -> type index
s EnvEntry
    name: Str
    type_idx: Int

# Type checking context
s TypeContext
    types: [Type]           # All types (indexed)
    env: [EnvEntry]         # Vformable environment
    errors: [TypeError]     # Accumulated errors
    fn_env: [FnSig]         # Known function signatures
    next_var: Int           # Next type vformable id

s FnSig
    name: Str
    param_types: [Int]      # indices into types
    ret_type: Int           # index into types

f ctx_new() -> TypeContext
    # Initialize with primitive types
    types := [ty_unknown(), ty_unit(), ty_int(), ty_float(), ty_bool(), ty_char(), ty_str()]
    TypeContext {
        types: types,
        env: [],
        errors: [],
        fn_env: [],
        next_var: 0
    }

# Add a type to the context, return (new_ctx, type_index)
f ctx_add_type(ctx: TypeContext, ty: Type) -> (TypeContext, Int)
    idx := vec_len(ctx.types)
    new_types := vec_push(ctx.types, ty)
    (TypeContext { types: new_types, env: ctx.env, errors: ctx.errors, fn_env: ctx.fn_env, next_var: ctx.next_var }, idx)

# Add an error to the context
f ctx_add_error(ctx: TypeContext, err: TypeError) -> TypeContext
    new_errors := vec_push(ctx.errors, err)
    TypeContext { types: ctx.types, env: ctx.env, errors: new_errors, fn_env: ctx.fn_env, next_var: ctx.next_var }

# Add a vformable binding to the environment
f ctx_add_var(ctx: TypeContext, name: Str, type_idx: Int) -> TypeContext
    entry := EnvEntry { name: name, type_idx: type_idx }
    new_env := vec_push(ctx.env, entry)
    TypeContext { types: ctx.types, env: new_env, errors: ctx.errors, fn_env: ctx.fn_env, next_var: ctx.next_var }

# Look up a vformable in the environment
f ctx_lookup_var(ctx: TypeContext, name: Str) -> Int
    lookup_var_loop(ctx.env, name, vec_len(ctx.env) - 1)

f lookup_var_loop(env: [EnvEntry], name: Str, idx: Int) -> Int
    if idx < 0 then -1
    else
        entry := env[idx]
        if entry.name == name then entry.type_idx
        else lookup_var_loop(env, name, idx - 1)

# Add a function signature
f ctx_add_fn(ctx: TypeContext, sig: FnSig) -> TypeContext
    new_fn_env := vec_push(ctx.fn_env, sig)
    TypeContext { types: ctx.types, env: ctx.env, errors: ctx.errors, fn_env: new_fn_env, next_var: ctx.next_var }

# Look up a function signature
f ctx_lookup_fn(ctx: TypeContext, name: Str) -> Option[FnSig]
    lookup_fn_loop(ctx.fn_env, name, 0)

f lookup_fn_loop(fns: [FnSig], name: Str, idx: Int) -> Option[FnSig]
    if idx >= vec_len(fns) then None
    else
        sig := fns[idx]
        if sig.name == name then Some(sig)
        else lookup_fn_loop(fns, name, idx + 1)

# Primitive type indices (pre-allocated in ctx_new)
f IDX_UNKNOWN() -> Int = 0
f IDX_UNIT() -> Int = 1
f IDX_INT() -> Int = 2
f IDX_FLOAT() -> Int = 3
f IDX_BOOL() -> Int = 4
f IDX_CHAR() -> Int = 5
f IDX_STR() -> Int = 6

# ============================================================================
# Type Name Conversion
# ============================================================================

f type_name(ctx: TypeContext, idx: Int) -> Str
    if idx < 0 then "unknown"
    else if idx >= vec_len(ctx.types) then "unknown"
    else
        ty := ctx.types[idx]
        if ty.kind == TY_UNKNOWN() then "unknown"
        else if ty.kind == TY_UNIT() then "()"
        else if ty.kind == TY_INT() then "Int"
        else if ty.kind == TY_FLOAT() then "Float"
        else if ty.kind == TY_BOOL() then "Bool"
        else if ty.kind == TY_CHAR() then "Char"
        else if ty.kind == TY_STR() then "Str"
        else if ty.kind == TY_NAMED() then ty.name
        else if ty.kind == TY_OPTION() then "Option"
        else if ty.kind == TY_ARRAY() then "Array"
        else if ty.kind == TY_FN() then "Fn"
        else "?"

# ============================================================================
# Type Equality
# ============================================================================

f types_equal(ctx: TypeContext, idx1: Int, idx2: Int) -> Bool
    if idx1 == idx2 then true
    else if idx1 < 0 || idx2 < 0 then false
    else if idx1 >= vec_len(ctx.types) || idx2 >= vec_len(ctx.types) then false
    else types_equal_inner(ctx, idx1, idx2)

f types_equal_inner(ctx: TypeContext, idx1: Int, idx2: Int) -> Bool
    t1 := ctx.types[idx1]
    t2 := ctx.types[idx2]
    if t1.kind != t2.kind then false
    else if t1.kind == TY_NAMED() then t1.name == t2.name
    else if t1.kind == TY_OPTION() || t1.kind == TY_ARRAY() then types_equal(ctx, t1.inner, t2.inner)
    else true

# Helper: check if type is Bool, add error if not
f check_is_bool(ctx: TypeContext, ty: Int, span: Span) -> TypeContext
    if types_equal(ctx, ty, IDX_BOOL()) then ctx
    else ctx_add_error(ctx, type_error_mismatch(span, "Bool", type_name(ctx, ty)))

# Helper: check if two types match, add error if not
f check_types_match(ctx: TypeContext, expected: Int, found: Int, span: Span) -> TypeContext
    if types_equal(ctx, expected, found) then ctx
    else ctx_add_error(ctx, type_error_mismatch(span, type_name(ctx, expected), type_name(ctx, found)))

# Helper: get element type for index access
f infer_index_result(ctx: TypeContext, arr_ty: Int) -> (TypeContext, Int)
    if arr_ty < 0 || arr_ty >= vec_len(ctx.types) then (ctx, IDX_UNKNOWN())
    else
        ty := ctx.types[arr_ty]
        if ty.kind == TY_ARRAY() then (ctx, ty.inner)
        else if ty.kind == TY_STR() then (ctx, IDX_CHAR())
        else (ctx, IDX_UNKNOWN())

# ============================================================================
# Expression Type Inference
# ============================================================================

# Infer type of an expression, returns (updated_ctx, type_index)
f infer_expr(ctx: TypeContext, ast: AST, expr_idx: Int) -> (TypeContext, Int)
    if expr_idx < 0 || expr_idx >= vec_len(ast.exprs) then
        (ctx, IDX_UNKNOWN())
    else
        expr := ast.exprs[expr_idx]

        # Integer literal
        if expr.kind == EXPR_INT() then (ctx, IDX_INT())

        # Float literal
        else if expr.kind == EXPR_FLOAT() then (ctx, IDX_FLOAT())

        # Bool literal
        else if expr.kind == EXPR_BOOL() then (ctx, IDX_BOOL())

        # Char literal
        else if expr.kind == EXPR_CHAR() then (ctx, IDX_CHAR())

        # String literal
        else if expr.kind == EXPR_STR() then (ctx, IDX_STR())

        # Identifier
        else if expr.kind == EXPR_IDENT() then
            type_idx := ctx_lookup_var(ctx, expr.name)
            if type_idx < 0 then
                err := type_error("undefined vformable", expr.span)
                (ctx_add_error(ctx, err), IDX_UNKNOWN())
            else
                (ctx, type_idx)

        # Binary operation
        else if expr.kind == EXPR_BINARY() then
            infer_binary(ctx, ast, expr)

        # Unary operation
        else if expr.kind == EXPR_UNARY() then
            infer_unary(ctx, ast, expr)

        # Function call
        else if expr.kind == EXPR_CALL() then
            infer_call(ctx, ast, expr)

        # If expression
        else if expr.kind == EXPR_IF() then
            infer_if(ctx, ast, expr)

        # Block expression
        else if expr.kind == EXPR_BLOCK() then
            infer_block(ctx, ast, expr)

        # Return
        else if expr.kind == EXPR_RETURN() then
            if expr.operand >= 0 then infer_expr(ctx, ast, expr.operand)
            else (ctx, IDX_UNIT())

        # Break/Continue return unit
        else if expr.kind == EXPR_BREAK() || expr.kind == EXPR_CONTINUE() then
            (ctx, IDX_UNIT())

        # While loop returns unit
        else if expr.kind == EXPR_WHILE() then
            (ctx2, cond_ty) := infer_expr(ctx, ast, expr.condition)
            ctx3 := check_is_bool(ctx2, cond_ty, expr.span)
            (ctx4, _) := infer_expr(ctx3, ast, expr.body_block)
            (ctx4, IDX_UNIT())

        # Array literal
        else if expr.kind == EXPR_ARRAY() then
            infer_array(ctx, ast, expr)

        # Tuple literal
        else if expr.kind == EXPR_TUPLE() then
            infer_tuple(ctx, ast, expr)

        # Field access
        else if expr.kind == EXPR_FIELD() then
            # For now, just infer the object type
            (ctx2, _) := infer_expr(ctx, ast, expr.object)
            (ctx2, IDX_UNKNOWN())  # Need struct type info to resolve field

        # Index access
        else if expr.kind == EXPR_INDEX() then
            (ctx2, arr_ty) := infer_expr(ctx, ast, expr.left)
            (ctx3, idx_ty) := infer_expr(ctx2, ast, expr.right)
            ctx4 := check_types_match(ctx3, IDX_INT(), idx_ty, expr.span)
            infer_index_result(ctx4, arr_ty)

        # Match expression
        else if expr.kind == EXPR_MATCH() then
            infer_match(ctx, ast, expr)

        # Unknown expression kind
        else
            (ctx, IDX_UNKNOWN())

# ============================================================================
# Binary Operation Type Inference
# ============================================================================

f infer_binary(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, left_ty) := infer_expr(ctx, ast, expr.left)
    (ctx3, right_ty) := infer_expr(ctx2, ast, expr.right)

    op := expr.op

    # Arithmetic: +, -, *, /, %
    if op == OP_ADD() || op == OP_SUB() || op == OP_MUL() || op == OP_DIV() || op == OP_REM() then
        # Both operands must be same numeric type
        if types_equal(ctx3, left_ty, IDX_INT()) && types_equal(ctx3, right_ty, IDX_INT()) then
            (ctx3, IDX_INT())
        else if types_equal(ctx3, left_ty, IDX_FLOAT()) && types_equal(ctx3, right_ty, IDX_FLOAT()) then
            (ctx3, IDX_FLOAT())
        # String concatenation with +
        else if op == OP_ADD() && types_equal(ctx3, left_ty, IDX_STR()) && types_equal(ctx3, right_ty, IDX_STR()) then
            (ctx3, IDX_STR())
        else
            err := type_error_mismatch(expr.span, type_name(ctx3, left_ty), type_name(ctx3, right_ty))
            (ctx_add_error(ctx3, err), IDX_UNKNOWN())

    # Comparison: ==, !=, <, <=, >, >=
    else if op == OP_EQ() || op == OP_NE() || op == OP_LT() || op == OP_LE() || op == OP_GT() || op == OP_GE() then
        # Both operands must be same type
        if types_equal(ctx3, left_ty, right_ty) then
            (ctx3, IDX_BOOL())
        else
            err := type_error_mismatch(expr.span, type_name(ctx3, left_ty), type_name(ctx3, right_ty))
            (ctx_add_error(ctx3, err), IDX_BOOL())

    # Logical: &&, ||
    else if op == OP_AND() || op == OP_OR() then
        ctx4 := check_is_bool(ctx3, left_ty, expr.span)
        ctx5 := check_is_bool(ctx4, right_ty, expr.span)
        (ctx5, IDX_BOOL())

    else
        (ctx3, IDX_UNKNOWN())

# ============================================================================
# Unary Operation Type Inference
# ============================================================================

f infer_unary(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, operand_ty) := infer_expr(ctx, ast, expr.operand)

    op := expr.op

    # Negation: -
    if op == UNOP_NEG() then
        if types_equal(ctx2, operand_ty, IDX_INT()) then (ctx2, IDX_INT())
        else if types_equal(ctx2, operand_ty, IDX_FLOAT()) then (ctx2, IDX_FLOAT())
        else
            err := type_error("negation requires numeric type", expr.span)
            (ctx_add_error(ctx2, err), IDX_UNKNOWN())

    # Logical not: !
    else if op == UNOP_NOT() then
        if types_equal(ctx2, operand_ty, IDX_BOOL()) then (ctx2, IDX_BOOL())
        else
            err := type_error_mismatch(expr.span, "Bool", type_name(ctx2, operand_ty))
            (ctx_add_error(ctx2, err), IDX_BOOL())

    else
        (ctx2, IDX_UNKNOWN())

# ============================================================================
# Function Call Type Inference
# ============================================================================

f infer_call(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    # Get callee name
    if expr.callee < 0 || expr.callee >= vec_len(ast.exprs) then
        (ctx, IDX_UNKNOWN())
    else
        callee := ast.exprs[expr.callee]
        if callee.kind != EXPR_IDENT() then
            # Can't infer for non-identifier callees yet
            (ctx, IDX_UNKNOWN())
        else
            fn_name := callee.name

            # Look up function signature
            maybe_sig := ctx_lookup_fn(ctx, fn_name)
            m maybe_sig
                Some(sig) ->
                    # Check argument count
                    if vec_len(expr.args) != vec_len(sig.param_types) then
                        err := type_error("wrong number of arguments", expr.span)
                        (ctx_add_error(ctx, err), sig.ret_type)
                    else
                        # Check each argument type
                        ctx2 := check_args(ctx, ast, expr.args, sig.param_types, 0, expr.span)
                        (ctx2, sig.ret_type)
                None ->
                    # Unknown function - check args but return unknown
                    ctx2 := check_args_no_sig(ctx, ast, expr.args, 0)
                    (ctx2, IDX_UNKNOWN())

f check_args(ctx: TypeContext, ast: AST, args: [Int], param_types: [Int], idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(args) then ctx
    else
        (ctx2, arg_ty) := infer_expr(ctx, ast, args[idx])
        param_ty := param_types[idx]
        ctx3 := check_types_match(ctx2, param_ty, arg_ty, span)
        check_args(ctx3, ast, args, param_types, idx + 1, span)

f check_args_no_sig(ctx: TypeContext, ast: AST, args: [Int], idx: Int) -> TypeContext
    if idx >= vec_len(args) then ctx
    else
        (ctx2, _) := infer_expr(ctx, ast, args[idx])
        check_args_no_sig(ctx2, ast, args, idx + 1)

# ============================================================================
# If Expression Type Inference
# ============================================================================

f infer_if(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, cond_ty) := infer_expr(ctx, ast, expr.condition)
    ctx3 := check_is_bool(ctx2, cond_ty, expr.span)
    (ctx4, then_ty) := infer_expr(ctx3, ast, expr.then_branch)
    if expr.else_branch >= 0 then infer_if_else(ctx4, ast, expr, then_ty)
    else (ctx4, then_ty)

f infer_if_else(ctx: TypeContext, ast: AST, expr: ExprNode, then_ty: Int) -> (TypeContext, Int)
    (ctx2, else_ty) := infer_expr(ctx, ast, expr.else_branch)
    ctx3 := check_types_match(ctx2, then_ty, else_ty, expr.span)
    (ctx3, then_ty)

# ============================================================================
# Block Type Inference
# ============================================================================

f infer_block(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    infer_stmts(ctx, ast, expr.stmts, 0)

f infer_stmts(ctx: TypeContext, ast: AST, stmts: [Int], idx: Int) -> (TypeContext, Int)
    if idx >= vec_len(stmts) then
        (ctx, IDX_UNIT())
    else
        stmt_idx := stmts[idx]
        if stmt_idx < 0 || stmt_idx >= vec_len(ast.stmts) then
            (ctx, IDX_UNIT())
        else
            stmt := ast.stmts[stmt_idx]

            # Expression statement
            if stmt.kind == STMT_EXPR() then
                (ctx2, ty) := infer_expr(ctx, ast, stmt.expr)
                # If last statement, return its type
                if idx + 1 >= vec_len(stmts) then (ctx2, ty)
                else infer_stmts(ctx2, ast, stmts, idx + 1)

            # Let statement
            else if stmt.kind == STMT_LET() then
                (ctx2, init_ty) := infer_expr(ctx, ast, stmt.init)
                ctx3 := add_let_binding(ctx2, ast, stmt, init_ty)
                infer_stmts(ctx3, ast, stmts, idx + 1)

f add_let_binding(ctx: TypeContext, ast: AST, stmt: StmtNode, init_ty: Int) -> TypeContext
    if stmt.pattern < 0 || stmt.pattern >= vec_len(ast.patterns) then ctx
    else
        pat := ast.patterns[stmt.pattern]
        if pat.kind == PAT_IDENT() then ctx_add_var(ctx, pat.name, init_ty) else ctx

# ============================================================================
# Array Type Inference
# ============================================================================

f infer_array(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    if vec_len(expr.elements) == 0 then
        # Empty array - type unknown
        (ctx, IDX_UNKNOWN())
    else
        # Infer type of first element
        (ctx2, elem_ty) := infer_expr(ctx, ast, expr.elements[0])
        # Check all elements have same type
        ctx3 := check_array_elements(ctx2, ast, expr.elements, elem_ty, 1, expr.span)
        # Create array type
        arr_ty := ty_array(elem_ty)
        (new_ctx, arr_idx) := ctx_add_type(ctx3, arr_ty)
        (new_ctx, arr_idx)

f check_array_elements(ctx: TypeContext, ast: AST, elements: [Int], expected_ty: Int, idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(elements) then ctx
    else
        (ctx2, elem_ty) := infer_expr(ctx, ast, elements[idx])
        ctx3 := check_types_match(ctx2, expected_ty, elem_ty, span)
        check_array_elements(ctx3, ast, elements, expected_ty, idx + 1, span)

# ============================================================================
# Tuple Type Inference
# ============================================================================

f infer_tuple(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    (ctx2, elem_types) := infer_tuple_elements(ctx, ast, expr.elements, 0, [])
    tuple_ty := type_new(TY_TUPLE())
    tuple_ty = Type { kind: tuple_ty.kind, name: tuple_ty.name, elements: elem_types, inner: tuple_ty.inner, ok_type: tuple_ty.ok_type, err_type: tuple_ty.err_type, ret_type: tuple_ty.ret_type, var_id: tuple_ty.var_id }
    (new_ctx, tuple_idx) := ctx_add_type(ctx2, tuple_ty)
    (new_ctx, tuple_idx)

f infer_tuple_elements(ctx: TypeContext, ast: AST, elements: [Int], idx: Int, acc: [Int]) -> (TypeContext, [Int])
    if idx >= vec_len(elements) then (ctx, acc)
    else
        (ctx2, elem_ty) := infer_expr(ctx, ast, elements[idx])
        new_acc := vec_push(acc, elem_ty)
        infer_tuple_elements(ctx2, ast, elements, idx + 1, new_acc)

# ============================================================================
# Match Type Inference
# ============================================================================

f infer_match(ctx: TypeContext, ast: AST, expr: ExprNode) -> (TypeContext, Int)
    # Infer scrutinee type
    (ctx2, scrut_ty) := infer_expr(ctx, ast, expr.scrutinee)

    # Infer arm types and check they match
    if vec_len(expr.arms) == 0 then (ctx2, IDX_UNKNOWN())
    else
        # Get first arm's result type
        first_arm_idx := expr.arms[0]
        (ctx3, first_ty) := infer_match_arm_body(ctx2, ast, first_arm_idx)
        # Check remaining arms match
        ctx4 := check_match_arms(ctx3, ast, expr.arms, first_ty, 1, expr.span)
        (ctx4, first_ty)

f infer_match_arm_body(ctx: TypeContext, ast: AST, arm_idx: Int) -> (TypeContext, Int)
    if arm_idx < 0 || arm_idx >= vec_len(ast.match_arms) then (ctx, IDX_UNKNOWN())
    else
        arm := ast.match_arms[arm_idx]
        infer_expr(ctx, ast, arm.body)

f check_match_arms(ctx: TypeContext, ast: AST, arms: [Int], expected_ty: Int, idx: Int, span: Span) -> TypeContext
    if idx >= vec_len(arms) then ctx
    else
        (ctx2, arm_ty) := infer_match_arm_body(ctx, ast, arms[idx])
        ctx3 := check_types_match(ctx2, expected_ty, arm_ty, span)
        check_match_arms(ctx3, ast, arms, expected_ty, idx + 1, span)

# ============================================================================
# Function Type Checking
# ============================================================================

# Register function signature from AST
f register_function(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    # Convert parameters to type indices
    (ctx2, param_types) := convert_params(ctx, ast, item.params, 0, [])

    # Convert return type
    (ctx3, ret_ty) := convert_ast_type(ctx2, ast, item.return_type)

    # Create signature
    sig := FnSig { name: item.name, param_types: param_types, ret_type: ret_ty }
    ctx_add_fn(ctx3, sig)

f convert_params(ctx: TypeContext, ast: AST, params: [(Str, Int)], idx: Int, acc: [Int]) -> (TypeContext, [Int])
    if idx >= vec_len(params) then (ctx, acc)
    else
        (param_name, type_idx) := params[idx]
        (ctx2, ty) := convert_ast_type(ctx, ast, type_idx)
        new_acc := vec_push(acc, ty)
        convert_params(ctx2, ast, params, idx + 1, new_acc)

f convert_ast_type(ctx: TypeContext, ast: AST, type_idx: Int) -> (TypeContext, Int)
    if type_idx < 0 || type_idx >= vec_len(ast.types) then (ctx, IDX_UNKNOWN())
    else
        ty := ast.types[type_idx]
        if ty.kind == TYPE_NAMED() then
            name := ty.name
            if name == "Int" then (ctx, IDX_INT())
            else if name == "Float" then (ctx, IDX_FLOAT())
            else if name == "Bool" then (ctx, IDX_BOOL())
            else if name == "Char" then (ctx, IDX_CHAR())
            else if name == "Str" then (ctx, IDX_STR())
            else
                # User-defined type
                named_ty := ty_named(name)
                ctx_add_type(ctx, named_ty)
        else (ctx, IDX_UNKNOWN())

# Check a function's body matches its declared return type
f check_function(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    # Get declared return type
    (ctx2, ret_ty) := convert_ast_type(ctx, ast, item.return_type)

    # Add parameters to environment
    ctx3 := add_params_to_env(ctx2, ast, item.params, 0)

    # Infer body type
    (ctx4, body_ty) := infer_expr(ctx3, ast, item.body)

    # Check body type matches return type
    if item.return_type >= 0 && !types_equal(ctx4, body_ty, ret_ty) then
        err := type_error_mismatch(item.span, type_name(ctx4, ret_ty), type_name(ctx4, body_ty))
        ctx_add_error(ctx4, err)
    else ctx4

f add_params_to_env(ctx: TypeContext, ast: AST, params: [(Str, Int)], idx: Int) -> TypeContext
    if idx >= vec_len(params) then ctx
    else
        (param_name, type_idx) := params[idx]
        (ctx2, ty) := convert_ast_type(ctx, ast, type_idx)
        ctx3 := ctx_add_var(ctx2, param_name, ty)
        add_params_to_env(ctx3, ast, params, idx + 1)

# ============================================================================
# Main Type Checking Entry Point
# ============================================================================

# Type check an entire AST
f type_check(ast: AST) -> (TypeContext, Bool)
    ctx := ctx_new()

    # First pass: register all function signatures
    ctx2 := register_all_functions(ctx, ast, 0)

    # Second pass: check all function bodies
    ctx3 := check_all_functions(ctx2, ast, 0)

    # Return context and whether there were errors
    has_errors := vec_len(ctx3.errors) > 0
    (ctx3, !has_errors)

f register_all_functions(ctx: TypeContext, ast: AST, idx: Int) -> TypeContext
    if idx >= vec_len(ast.items) then ctx
    else
        item := ast.items[idx]
        ctx2 := register_fn_if_fn(ctx, ast, item)
        register_all_functions(ctx2, ast, idx + 1)

f register_fn_if_fn(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    if item.kind == ITEM_FN() then register_function(ctx, ast, item) else ctx

f check_all_functions(ctx: TypeContext, ast: AST, idx: Int) -> TypeContext
    if idx >= vec_len(ast.items) then ctx
    else
        item := ast.items[idx]
        ctx2 := check_fn_if_fn(ctx, ast, item)
        check_all_functions(ctx2, ast, idx + 1)

f check_fn_if_fn(ctx: TypeContext, ast: AST, item: ItemNode) -> TypeContext
    if item.kind == ITEM_FN() then check_function(ctx, ast, item) else ctx

# ============================================================================
# Error Formatting
# ============================================================================

f format_errors(ctx: TypeContext) -> Str
    format_errors_loop(ctx.errors, 0, "")

f format_errors_loop(errors: [TypeError], idx: Int, acc: Str) -> Str
    if idx >= vec_len(errors) then acc
    else
        err := errors[idx]
        # Simplified error formatting without string concatenation
        format_errors_loop(errors, idx + 1, err.message)

# Print a type error
f print_error(err: TypeError) -> Int
    print(err.message)
    0
