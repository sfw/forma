# FORMA Standard Library - Core Module
# Provides fundamental utilities for assertions and numeric operations

# ============================================================
# Assertion helpers
# ============================================================

# Assert that two integers are equal
f assert_eq(actual: Int, expected: Int, msg: Str) -> Bool
    if actual == expected then true
    else
        print("Assertion failed:")
        print(msg)
        print("Expected:")
        print(expected)
        print("Actual:")
        print(actual)
        false

# Assert that two strings are equal
f assert_str_eq(actual: Str, expected: Str, msg: Str) -> Bool
    if actual == expected then true
    else
        print("Assertion failed:")
        print(msg)
        print("Expected:")
        print(expected)
        print("Actual:")
        print(actual)
        false

# Assert that a boolean is true
f assert_true(cond: Bool, msg: Str) -> Bool
    if cond then true
    else
        print("Assertion failed:")
        print(msg)
        false

# Assert that a boolean is false
f assert_false(cond: Bool, msg: Str) -> Bool
    if !cond then true
    else
        print("Assertion failed (expected false):")
        print(msg)
        false

# ============================================================
# Numeric utilities
# ============================================================

# Absolute value
f abs(n: Int) -> Int
    if n < 0 then 0 - n else n

# Minimum of two integers
f min(a: Int, b: Int) -> Int
    if a < b then a else b

# Maximum of two integers
f max(a: Int, b: Int) -> Int
    if a > b then a else b

# Clamp a value between min and max
f clamp(value: Int, min_val: Int, max_val: Int) -> Int
    if value < min_val then min_val
    else if value > max_val then max_val
    else value

# Sign of an integer: -1, 0, or 1
f sign(n: Int) -> Int
    if n < 0 then 0 - 1
    else if n > 0 then 1
    else 0

# Power function (integer exponent) using exponentiation by squaring
# O(log n) operations, tail-recursive via accumulator pattern
# For negative exponents: returns 0 for |base| > 1 (integer division rounds down)
f pow(base: Int, exp: Int) -> Int
    if exp < 0 then
        # Integer power with negative exponent
        if base == 1 then 1
        else if base == 0 - 1 then
            if exp % 2 == 0 then 1 else 0 - 1
        else 0
    else
        pow_acc(base, exp, 1)

# Tail-recursive helper using exponentiation by squaring
f pow_acc(base: Int, exp: Int, acc: Int) -> Int
    if exp == 0 then acc
    else if exp % 2 == 0 then
        # Even exponent: square base, halve exponent
        pow_acc(base * base, exp / 2, acc)
    else
        # Odd exponent: multiply acc by base, then square
        pow_acc(base * base, exp / 2, acc * base)

# GCD using Euclidean algorithm
f gcd(a: Int, b: Int) -> Int
    if b == 0 then abs(a)
    else gcd(b, a % b)

# LCM using GCD (divide before multiply to prevent overflow)
f lcm(a: Int, b: Int) -> Int
    if a == 0 || b == 0 then 0
    else abs(a / gcd(a, b)) * abs(b)

# Check if a number is even
f is_even(n: Int) -> Bool
    n % 2 == 0

# Check if a number is odd
f is_odd(n: Int) -> Bool
    n % 2 != 0

# Check if a number is positive
f is_positive(n: Int) -> Bool
    n > 0

# Check if a number is negative
f is_negative(n: Int) -> Bool
    n < 0

# Check if a number is zero
f is_zero(n: Int) -> Bool
    n == 0
