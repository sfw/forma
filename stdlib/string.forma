# FORMA Standard Library - String Module
# Provides string manipulation utilities and StringBuilder pattern

# ============================================================
# String predicates
# ============================================================

# Check if string is empty
f str_is_empty(s: Str) -> Bool
    str_len(s) == 0

# Check if string is blank (empty or only whitespace)
f str_is_blank(s: Str) -> Bool
    str_is_empty(str_trim(s))

# ============================================================
# String transformation
# ============================================================

# Repeat a string n times
f str_repeat(s: Str, n: Int) -> Str
    result := ""
    idx := 0
    wh idx < n
        result = str_concat(result, s)
        idx = idx + 1
    result

# Pad string on the left to reach target length
f str_pad_left(s: Str, target_len: Int, pad_char: Str) -> Str
    current_len := str_len(s)
    if current_len >= target_len then s
    else
        padding := str_repeat(pad_char, target_len - current_len)
        str_concat(padding, s)

# Pad string on the right to reach target length
f str_pad_right(s: Str, target_len: Int, pad_char: Str) -> Str
    current_len := str_len(s)
    if current_len >= target_len then s
    else
        padding := str_repeat(pad_char, target_len - current_len)
        str_concat(s, padding)

# Replace first occurrence of pattern with replacement
f str_replace_first(s: Str, pattern: Str, replacement: Str) -> Str
    # Find pattern location by checking all positions
    s_len := str_len(s)
    p_len := str_len(pattern)

    if p_len > s_len then s
    else
        found_idx := 0 - 1
        idx := 0
        wh idx <= s_len - p_len && found_idx < 0
            substr := str_slice(s, idx, idx + p_len)
            if substr == pattern then found_idx = idx else found_idx = found_idx
            idx = idx + 1

        if found_idx < 0 then s
        else
            before := str_slice(s, 0, found_idx)
            after := str_slice(s, found_idx + p_len, s_len)
            str_concat(str_concat(before, replacement), after)

# ============================================================
# String joining and splitting
# ============================================================

# Join array of strings with separator
f str_join(parts: [Str], sep: Str) -> Str
    len := vec_len(parts)
    if len == 0 then ""
    else
        result := parts[0]
        idx := 1
        wh idx < len
            result = str_concat(str_concat(result, sep), parts[idx])
            idx = idx + 1
        result

# Split string into lines
f str_lines(s: Str) -> [Str]
    str_split(s, "\n")

# Split string into words (by whitespace)
f str_words(s: Str) -> [Str]
    # Simple implementation: split by spaces
    str_split(s, " ")

# ============================================================
# StringBuilder pattern using array of strings
# ============================================================

# Create a new string builder (empty array of strings)
f sb_new() -> [Str]
    []

# Append a string to the builder
f sb_append(builder: [Str], s: Str) -> [Str]
    vec_push(builder, s)

# Append a string followed by newline
f sb_append_line(builder: [Str], s: Str) -> [Str]
    vec_push(vec_push(builder, s), "\n")

# Append just a newline
f sb_newline(builder: [Str]) -> [Str]
    vec_push(builder, "\n")

# Build the final string from the builder
f sb_build(builder: [Str]) -> Str
    str_join(builder, "")

# Append an integer as string
f sb_append_int(builder: [Str], n: Int) -> [Str]
    vec_push(builder, int_to_str(n))

# ============================================================
# Character utilities
# ============================================================

# Convert char to single-character string
f str_from_char(c: Char) -> Str
    char_to_str(c)

# Get character at index as string (single char)
# Note: Commented out due to type inference issue with match arms
# f str_char_at_str(s: Str, idx: Int) -> Option[Str]
#     m str_char_at(s, idx)
#         Some(c) -> Some(str_from_char(c))
#         None -> None

# Check if character is a digit
f is_digit(c: Char) -> Bool
    char_is_digit(c)

# Check if character is a letter
f is_alpha(c: Char) -> Bool
    char_is_alpha(c)

# Check if character is alphanumeric
f is_alphanumeric(c: Char) -> Bool
    char_is_alphanumeric(c)

# Check if character is whitespace
f is_whitespace(c: Char) -> Bool
    char_is_whitespace(c)

# ============================================================
# Parsing utilities
# ============================================================

# Parse integer from string, returning Option
f parse_int(s: Str) -> Option[Int]
    str_to_int(s)

# Parse integer with default value
f parse_int_or(s: Str, default: Int) -> Int
    m str_to_int(s)
        Some(n) -> n
        None -> default

# Check if string represents a valid integer
f str_is_int(s: Str) -> Bool
    m str_to_int(s)
        Some(_) -> true
        None -> false

# ============================================================
# Comparison and search
# ============================================================

# Compare strings lexicographically
# Returns: -1 if a < b, 0 if a == b, 1 if a > b
f str_compare(a: Str, b: Str) -> Int
    len_a := str_len(a)
    len_b := str_len(b)
    min_len := if len_a < len_b then len_a else len_b

    idx := 0
    result := 0
    wh idx < min_len && result == 0
        m str_char_at(a, idx)
            Some(ca) ->
                m str_char_at(b, idx)
                    Some(cb) ->
                        code_a := char_to_int(ca)
                        code_b := char_to_int(cb)
                        if code_a < code_b then result = 0 - 1
                        else if code_a > code_b then result = 1
                        else result = 0
                    None -> result = 1
            None -> result = 0 - 1
        idx = idx + 1

    if result != 0 then result
    else if len_a < len_b then 0 - 1
    else if len_a > len_b then 1
    else 0

# Find index of substring, or -1 if not found
f str_index_of(haystack: Str, needle: Str) -> Int
    h_len := str_len(haystack)
    n_len := str_len(needle)

    if n_len > h_len then 0 - 1
    else if n_len == 0 then 0
    else
        result := 0 - 1
        idx := 0
        wh idx <= h_len - n_len && result < 0
            substr := str_slice(haystack, idx, idx + n_len)
            if substr == needle then result = idx else result = result
            idx = idx + 1
        result
