# FORMA Standard Library - Map Module
# Direct operations on built-in map type {Str: V}
# Uses built-in map functions: map_new, map_get, map_insert, map_remove, etc.

# ============================================================
# Direct map operations
# These work directly with the built-in {Str: V} type
# ============================================================

# The built-in map type {Str: V} can be used directly with:
# - map_new() -> {Str: V}
# - map_get(m, key) -> V?
# - map_insert(m, key, val) -> {Str: V}
# - map_remove(m, key) -> ({Str: V}, V?)
# - map_contains(m, key) -> Bool
# - map_len(m) -> Int
# - map_keys(m) -> [Str]
# - map_values(m) -> [V]

# ============================================================
# Int-specific helper operations on {Str: Int}
# ============================================================

# Sum all values in an int array
f int_sum_array(arr: [Int], idx: Int, acc: Int) -> Int
    if idx >= vec_len(arr) then acc
    else
        m vec_get(arr, idx)
            Some(x) -> int_sum_array(arr, idx + 1, acc + x)
            None -> acc

# Find max in array
f int_max_in_array(arr: [Int], idx: Int, current: Int) -> Int
    if idx >= vec_len(arr) then current
    else
        m vec_get(arr, idx)
            Some(x) ->
                new_max := if x > current then x else current
                int_max_in_array(arr, idx + 1, new_max)
            None -> current

# Find min in array
f int_min_in_array(arr: [Int], idx: Int, current: Int) -> Int
    if idx >= vec_len(arr) then current
    else
        m vec_get(arr, idx)
            Some(x) ->
                new_min := if x < current then x else current
                int_min_in_array(arr, idx + 1, new_min)
            None -> current

# ============================================================
# TODO: Generic Map[K,V] wrapper
# ============================================================
# The following functions require a Map[K,V] wrapper struct which has
# type inference limitations. They are commented out for now.
# Use the built-in {Str: V} map type directly instead.
#
# Wrapper pattern would be:
# s Map[K, V] { data: {Str: V} }
#
# With functions like:
# f map_empty[V]() -> Map[Str, V]
# f map_lookup[V](m: Map[Str, V], key: Str) -> V?
# f map_put[V](m: Map[Str, V], key: Str, value: V) -> Map[Str, V]
# etc.
