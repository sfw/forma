# GCD and LCM - Euclidean Algorithm
# Demonstrates: recursion, mathematical algorithms
#
# GCD (Greatest Common Divisor) using Euclid's algorithm
# LCM (Least Common Multiple) using GCD

# Euclidean algorithm (recursive)
f gcd(a: Int, b: Int) -> Int
    if b == 0 then abs(a)
    else gcd(b, a % b)

# Iterative version
f gcd_iter(a: Int, b: Int) -> Int
    x := abs(a)
    y := abs(b)
    wh y != 0
        temp := y
        y := x % y
        x := temp
    x

# LCM using GCD (avoid overflow by dividing first)
f lcm(a: Int, b: Int) -> Int
    if a == 0 || b == 0 then 0
    else abs(a / gcd(a, b)) * abs(b)

# Extended Euclidean algorithm
# Returns (gcd, x, y) such that a*x + b*y = gcd(a,b)
f extended_gcd(a: Int, b: Int) -> (Int, Int, Int)
    if b == 0 then
        (abs(a), 1, 0)
    else
        result := extended_gcd(b, a % b)
        g := result.0
        x := result.1
        y := result.2
        (g, y, x - (a / b) * y)

f main() -> Int
    print("GCD examples:")
    print(f"gcd(48, 18) = {gcd(48, 18)}")       # 6
    print(f"gcd(54, 24) = {gcd(54, 24)}")       # 6
    print(f"gcd(17, 13) = {gcd(17, 13)}")       # 1 (coprime)
    print(f"gcd(100, 35) = {gcd(100, 35)}")     # 5

    print("")
    print("LCM examples:")
    print(f"lcm(4, 6) = {lcm(4, 6)}")           # 12
    print(f"lcm(21, 6) = {lcm(21, 6)}")         # 42
    print(f"lcm(12, 18) = {lcm(12, 18)}")       # 36

    print("")
    print("Extended GCD (Bezout coefficients):")
    result := extended_gcd(35, 15)
    print(f"extended_gcd(35, 15) = ({result.0}, {result.1}, {result.2})")
    print(f"Verification: 35 * {result.1} + 15 * {result.2} = {35 * result.1 + 15 * result.2}")
    0
