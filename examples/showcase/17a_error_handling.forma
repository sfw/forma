# Error Handling - Option, Result, and safe patterns
# Demonstrates: Option/Result types, pattern matching, ? operator,
#               ?? coalesce, builtins (is_some, unwrap, unwrap_or, etc.)

# --- Option: representing optional values ---

# Safe division returns None on divide-by-zero
f safe_div(a: Int, b: Int) -> Int?
    if b == 0 then None
    else Some(a / b)

# --- Result: representing success or failure ---

# Parse a positive integer, returning an error message on failure
f parse_positive(s: Str) -> Int!Str
    m str_to_int(s)
        Some(n) if n > 0 -> Ok(n)
        Some(_) -> Err("not positive")
        None -> Err("not a number")

# --- Using the ? operator to propagate errors ---

f add_two_numbers(a: Str, b: Str) -> Int!Str
    x := parse_positive(a)?
    y := parse_positive(b)?
    Ok(x + y)

# --- Demo functions ---

f demo_option()
    print("=== Option ===")

    # Creating Option values
    some_val := Some(42)
    none_val := None

    # Pattern matching
    m some_val
        Some(v) -> print(f"Some contains: {v}")
        None -> print("None")

    # Checking with builtins
    print(f"is_some(Some(42)) = {is_some(some_val)}")
    print(f"is_none(Some(42)) = {is_none(some_val)}")
    print(f"is_some(None) = {is_some(none_val)}")
    print(f"is_none(None) = {is_none(none_val)}")

    # Unwrapping
    print(f"unwrap(Some(42)) = {unwrap(some_val)}")
    print(f"unwrap_or(Some(42), 0) = {unwrap_or(some_val, 0)}")
    print(f"unwrap_or(None, 99) = {unwrap_or(none_val, 99)}")
    print(f"expect(Some(42), \"oops\") = {expect(some_val, "oops")}")

    # Coalesce operator ??
    name := Some("Alice") ?? "unknown"
    fallback := None ?? "default"
    print(f"Some(\"Alice\") ?? \"unknown\" = {name}")
    print(f"None ?? \"default\" = {fallback}")

    print("")

f demo_result()
    print("=== Result ===")

    ok_val := Ok(100)
    err_val := Err("something went wrong")

    # Pattern matching
    m ok_val
        Ok(v) -> print(f"Ok contains: {v}")
        Err(e) -> print(f"Err: {e}")

    m err_val
        Ok(v) -> print(f"Ok: {v}")
        Err(e) -> print(f"Err contains: {e}")

    # Checking with builtins
    print(f"is_ok(Ok(100)) = {is_ok(ok_val)}")
    print(f"is_err(Ok(100)) = {is_err(ok_val)}")
    print(f"is_ok(Err(..)) = {is_ok(err_val)}")
    print(f"is_err(Err(..)) = {is_err(err_val)}")

    print("")

f demo_try_operator()
    print("=== Try Operator ? ===")

    # Success path: both parse as positive
    m add_two_numbers("3", "4")
        Ok(v) -> print(f"add_two_numbers(\"3\", \"4\") = Ok({v})")
        Err(e) -> print(f"add_two_numbers(\"3\", \"4\") = Err({e})")

    # Failure path: second arg is not a number
    m add_two_numbers("3", "abc")
        Ok(v) -> print(f"add_two_numbers(\"3\", \"abc\") = Ok({v})")
        Err(e) -> print(f"add_two_numbers(\"3\", \"abc\") = Err({e})")

    # Failure path: negative number
    m add_two_numbers("5", "-1")
        Ok(v) -> print(f"add_two_numbers(\"5\", \"-1\") = Ok({v})")
        Err(e) -> print(f"add_two_numbers(\"5\", \"-1\") = Err({e})")

    print("")

f demo_practical()
    print("=== Practical Patterns ===")

    # Safe division with pattern matching
    m safe_div(10, 3)
        Some(v) -> print(f"10 / 3 = {v}")
        None -> print("division by zero!")

    m safe_div(10, 0)
        Some(v) -> print(f"10 / 0 = {v}")
        None -> print("10 / 0 = division by zero!")

    # Safe division with default via ??
    result := safe_div(10, 0) ?? 0
    print(f"safe_div(10, 0) ?? 0 = {result}")

    # String parsing with str_to_int
    m str_to_int("42")
        Some(n) -> print(f"str_to_int(\"42\") = Some({n})")
        None -> print("str_to_int(\"42\") = None")

    m str_to_int("abc")
        Some(n) -> print(f"str_to_int(\"abc\") = Some({n})")
        None -> print("str_to_int(\"abc\") = None")

    # Safe array access with vec_get
    arr := [10, 20, 30]
    m vec_get(arr, 1)
        Some(v) -> print(f"vec_get(arr, 1) = Some({v})")
        None -> print("vec_get(arr, 1) = None")

    m vec_get(arr, 5)
        Some(v) -> print(f"vec_get(arr, 5) = Some({v})")
        None -> print("vec_get(arr, 5) = None")

    # Default value chains with ??
    val := vec_get(arr, 99) ?? 0
    print(f"vec_get(arr, 99) ?? 0 = {val}")

    # Chaining: parse then default
    parsed := str_to_int("hello") ?? 0
    print(f"str_to_int(\"hello\") ?? 0 = {parsed}")

    print("")

f main()
    demo_option()
    demo_result()
    demo_try_operator()
    demo_practical()
    print("Done!")
