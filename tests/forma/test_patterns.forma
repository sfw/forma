# Named contract pattern coverage

@nonempty(items)
@sorted(result)
@same_length(items, result)
@permutation(items, result)
f checked_sort(items: [Int]) -> [Int]
    sort_ints(items)

@positive(n)
@nonnegative(result)
f id_pos(n: Int) -> Int
    n

@nonzero(x)
@post(result * 2 == x)
f half(x: Int) -> Int
    x / 2

@bounded(x, 0, 100)
@nonnegative(result)
f bounded_identity(x: Int) -> Int
    x

@sorted_desc(result)
f descending_copy(items: [Int]) -> [Int]
    sort_ints_desc(items)

@unique(result)
f unique_passthrough(result: [Int]) -> [Int]
    result

@unchanged(x)
f unchanged_id(x: Int) -> Int
    x

f main() -> Int
    _ := checked_sort([4, 1, 4, 2])
    _ := id_pos(7)
    _ := half(8)
    _ := bounded_identity(42)
    _ := descending_copy([1, 3, 2])
    _ := unique_passthrough([1, 2, 3])
    _ := unchanged_id(5)
    0
